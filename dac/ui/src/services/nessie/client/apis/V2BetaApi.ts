/* tslint:disable */

/**
 * Nessie API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: ${project.version}
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import {
  CommitResponseV2,
  ContentKey,
  ContentResponseV2,
  DiffResponseV2,
  EntriesResponseV2,
  FetchOption,
  GetMultipleContentsRequest,
  GetMultipleContentsResponseV2,
  LogResponseV2,
  Merge,
  MergeResponseV2,
  NessieConfiguration,
  Operations,
  Reference,
  ReferenceType,
  ReferencesResponseV2,
  SingleReferenceResponseV2,
  Transplant,
} from "../models";

export interface AssignReferenceV2Request {
  ref: any;
  reference: Reference;
  type?: ReferenceType;
}

export interface CommitV2Request {
  branch: any;
  operations: Operations;
}

export interface CreateReferenceV2Request {
  name: string;
  type: ReferenceType;
  reference: Reference;
}

export interface DeleteReferenceV2Request {
  ref: any;
  type?: ReferenceType;
}

export interface GetAllReferencesV2Request {
  fetch?: FetchOption;
  filter?: string;
  maxRecords?: number;
  pageToken?: string;
}

export interface GetCommitLogV2Request {
  ref: any;
  fetch?: FetchOption;
  filter?: string;
  limitHash?: string;
  maxRecords?: number;
  pageToken?: string;
}

export interface GetContentV2Request {
  key: ContentKey;
  ref: any;
}

export interface GetDiffV2Request {
  fromRef: string;
  toRef: string;
  maxRecords?: number;
  pageToken?: string;
}

export interface GetEntriesV2Request {
  ref: any;
  content?: boolean;
  filter?: string;
  maxRecords?: number;
  pageToken?: string;
}

export interface GetMultipleContentsV2Request {
  ref: any;
  getMultipleContentsRequest?: GetMultipleContentsRequest;
}

export interface GetReferenceByNameV2Request {
  ref: string;
  fetch?: FetchOption;
}

export interface GetSeveralContentsRequest {
  ref: string;
  key?: Array<string>;
}

export interface MergeV2Request {
  branch: any;
  merge: Merge;
}

export interface TransplantV2Request {
  branch: any;
  transplant: Transplant;
}

/**
 *
 */
export class V2BetaApi extends runtime.BaseAPI {
  /**
   * The \'ref\' parameter identifies the branch or tag to be reassigned. The \'ref\' parameter may contain a hash qualifier. That hash as well as the optional \'type\' parameter may be used to ensure the operation is performed on the same object that the user expects.  Only branches and tags may be reassigned. The payload object identifies any reference visible to the current user whose \'hash\' will be used to define the new HEAD of the reference being reassigned. Detached hashes may be used in the payload.
   * Set a named reference to a specific hash via another reference.
   */
  async assignReferenceV2Raw(
    requestParameters: AssignReferenceV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<SingleReferenceResponseV2>> {
    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling assignReferenceV2.",
      );
    }

    if (
      requestParameters.reference === null ||
      requestParameters.reference === undefined
    ) {
      throw new runtime.RequiredError(
        "reference",
        "Required parameter requestParameters.reference was null or undefined when calling assignReferenceV2.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters["type"] = requestParameters.type;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v2/trees/{ref}`.replace(
          `{${"ref"}}`,
          encodeURIComponent(String(requestParameters.ref)),
        ),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.reference,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * The \'ref\' parameter identifies the branch or tag to be reassigned. The \'ref\' parameter may contain a hash qualifier. That hash as well as the optional \'type\' parameter may be used to ensure the operation is performed on the same object that the user expects.  Only branches and tags may be reassigned. The payload object identifies any reference visible to the current user whose \'hash\' will be used to define the new HEAD of the reference being reassigned. Detached hashes may be used in the payload.
   * Set a named reference to a specific hash via another reference.
   */
  async assignReferenceV2(
    requestParameters: AssignReferenceV2Request,
    initOverrides?: RequestInit,
  ): Promise<SingleReferenceResponseV2> {
    const response = await this.assignReferenceV2Raw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * The state of contents specified by the \'branch\' reference will be used for detecting conflicts with the operation being committed.  The hash in the successful response will be the hash of the commit that contains the requested operations, whose immediate parent commit will be the current HEAD of the specified branch.
   * Commit one or more operations against the given \'branch\'.
   */
  async commitV2Raw(
    requestParameters: CommitV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<CommitResponseV2>> {
    if (
      requestParameters.branch === null ||
      requestParameters.branch === undefined
    ) {
      throw new runtime.RequiredError(
        "branch",
        "Required parameter requestParameters.branch was null or undefined when calling commitV2.",
      );
    }

    if (
      requestParameters.operations === null ||
      requestParameters.operations === undefined
    ) {
      throw new runtime.RequiredError(
        "operations",
        "Required parameter requestParameters.operations was null or undefined when calling commitV2.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v2/trees/{branch}/history/commit`.replace(
          `{${"branch"}}`,
          encodeURIComponent(String(requestParameters.branch)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.operations,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * The state of contents specified by the \'branch\' reference will be used for detecting conflicts with the operation being committed.  The hash in the successful response will be the hash of the commit that contains the requested operations, whose immediate parent commit will be the current HEAD of the specified branch.
   * Commit one or more operations against the given \'branch\'.
   */
  async commitV2(
    requestParameters: CommitV2Request,
    initOverrides?: RequestInit,
  ): Promise<CommitResponseV2> {
    const response = await this.commitV2Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * The name and type query parameters define the kind of reference to be created. The payload object defines the new reference\'s origin in the commit history.  Only branches and tags can be created by this method, but the payload object may be any valid reference, including a detached commit. If the payload reference object does not define a commit hash, the HEAD of that reference will be used.
   * Create a new branch or tag
   */
  async createReferenceV2Raw(
    requestParameters: CreateReferenceV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<SingleReferenceResponseV2>> {
    if (
      requestParameters.name === null ||
      requestParameters.name === undefined
    ) {
      throw new runtime.RequiredError(
        "name",
        "Required parameter requestParameters.name was null or undefined when calling createReferenceV2.",
      );
    }

    if (
      requestParameters.type === null ||
      requestParameters.type === undefined
    ) {
      throw new runtime.RequiredError(
        "type",
        "Required parameter requestParameters.type was null or undefined when calling createReferenceV2.",
      );
    }

    if (
      requestParameters.reference === null ||
      requestParameters.reference === undefined
    ) {
      throw new runtime.RequiredError(
        "reference",
        "Required parameter requestParameters.reference was null or undefined when calling createReferenceV2.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.name !== undefined) {
      queryParameters["name"] = requestParameters.name;
    }

    if (requestParameters.type !== undefined) {
      queryParameters["type"] = requestParameters.type;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v2/trees`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.reference,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * The name and type query parameters define the kind of reference to be created. The payload object defines the new reference\'s origin in the commit history.  Only branches and tags can be created by this method, but the payload object may be any valid reference, including a detached commit. If the payload reference object does not define a commit hash, the HEAD of that reference will be used.
   * Create a new branch or tag
   */
  async createReferenceV2(
    requestParameters: CreateReferenceV2Request,
    initOverrides?: RequestInit,
  ): Promise<SingleReferenceResponseV2> {
    const response = await this.createReferenceV2Raw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * The \'ref\' parameter identifies the branch or tag to be deleted. The \'ref\' parameter may contain a hash qualifier. That hash as well as the optional \'type\' parameter may be used to ensure the operation is performed on the same object that the user expects.  Only branches and tags can be deleted. However, deleting the default branch may be restricted.
   * Delete a reference
   */
  async deleteReferenceV2Raw(
    requestParameters: DeleteReferenceV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<SingleReferenceResponseV2>> {
    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling deleteReferenceV2.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.type !== undefined) {
      queryParameters["type"] = requestParameters.type;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v2/trees/{ref}`.replace(
          `{${"ref"}}`,
          encodeURIComponent(String(requestParameters.ref)),
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * The \'ref\' parameter identifies the branch or tag to be deleted. The \'ref\' parameter may contain a hash qualifier. That hash as well as the optional \'type\' parameter may be used to ensure the operation is performed on the same object that the user expects.  Only branches and tags can be deleted. However, deleting the default branch may be restricted.
   * Delete a reference
   */
  async deleteReferenceV2(
    requestParameters: DeleteReferenceV2Request,
    initOverrides?: RequestInit,
  ): Promise<SingleReferenceResponseV2> {
    const response = await this.deleteReferenceV2Raw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Get information about all branches and tags
   */
  async getAllReferencesV2Raw(
    requestParameters: GetAllReferencesV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<ReferencesResponseV2>> {
    const queryParameters: any = {};

    if (requestParameters.fetch !== undefined) {
      queryParameters["fetch"] = requestParameters.fetch;
    }

    if (requestParameters.filter !== undefined) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.maxRecords !== undefined) {
      queryParameters["max-records"] = requestParameters.maxRecords;
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters["page-token"] = requestParameters.pageToken;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v2/trees`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get information about all branches and tags
   */
  async getAllReferencesV2(
    requestParameters: GetAllReferencesV2Request,
    initOverrides?: RequestInit,
  ): Promise<ReferencesResponseV2> {
    const response = await this.getAllReferencesV2Raw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Retrieve the commit log for a reference, potentially truncated by the backend.  The backend may respect the given \'max-entries\' records hint, or may return more or less entries. Backends may also cap the returned entries at a hard-coded limit  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all available data in one page.  Different pages may have different numbers of log records in them even if they come from another call to this method with the same parameters. Also, pages are not guaranteed to be filled to contain exactly \'maxRecords\' even if the total amount of available data allows that. Pages may contain more of less entries at server\'s discretion.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.  The fetching of the log starts from the HEAD of the given ref (or a more specific commit, if provided as part of the \'ref\' path element) and proceeds until the \'root\' commit or the \'limit-hash\' commit are encountered.
   * Get commit log for a particular reference
   */
  async getCommitLogV2Raw(
    requestParameters: GetCommitLogV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<LogResponseV2>> {
    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling getCommitLogV2.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.fetch !== undefined) {
      queryParameters["fetch"] = requestParameters.fetch;
    }

    if (requestParameters.filter !== undefined) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.limitHash !== undefined) {
      queryParameters["limit-hash"] = requestParameters.limitHash;
    }

    if (requestParameters.maxRecords !== undefined) {
      queryParameters["max-records"] = requestParameters.maxRecords;
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters["page-token"] = requestParameters.pageToken;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v2/trees/{ref}/history`.replace(
          `{${"ref"}}`,
          encodeURIComponent(String(requestParameters.ref)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Retrieve the commit log for a reference, potentially truncated by the backend.  The backend may respect the given \'max-entries\' records hint, or may return more or less entries. Backends may also cap the returned entries at a hard-coded limit  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all available data in one page.  Different pages may have different numbers of log records in them even if they come from another call to this method with the same parameters. Also, pages are not guaranteed to be filled to contain exactly \'maxRecords\' even if the total amount of available data allows that. Pages may contain more of less entries at server\'s discretion.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.  The fetching of the log starts from the HEAD of the given ref (or a more specific commit, if provided as part of the \'ref\' path element) and proceeds until the \'root\' commit or the \'limit-hash\' commit are encountered.
   * Get commit log for a particular reference
   */
  async getCommitLogV2(
    requestParameters: GetCommitLogV2Request,
    initOverrides?: RequestInit,
  ): Promise<LogResponseV2> {
    const response = await this.getCommitLogV2Raw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns repository and server settings relevant to clients.
   */
  async getConfigV2Raw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<NessieConfiguration>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v2/config`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Returns repository and server settings relevant to clients.
   */
  async getConfigV2(initOverrides?: RequestInit): Promise<NessieConfiguration> {
    const response = await this.getConfigV2Raw(initOverrides);
    return await response.value();
  }

  /**
   * This operation returns the content value for a content key at a particular point in history as defined by the \'ref\' parameter.
   * Get the content object associated with a key.
   */
  async getContentV2Raw(
    requestParameters: GetContentV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<ContentResponseV2>> {
    if (requestParameters.key === null || requestParameters.key === undefined) {
      throw new runtime.RequiredError(
        "key",
        "Required parameter requestParameters.key was null or undefined when calling getContentV2.",
      );
    }

    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling getContentV2.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v2/trees/{ref}/contents/{key}`
          .replace(
            `{${"key"}}`,
            encodeURIComponent(String(requestParameters.key)),
          )
          .replace(
            `{${"ref"}}`,
            encodeURIComponent(String(requestParameters.ref)),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * This operation returns the content value for a content key at a particular point in history as defined by the \'ref\' parameter.
   * Get the content object associated with a key.
   */
  async getContentV2(
    requestParameters: GetContentV2Request,
    initOverrides?: RequestInit,
  ): Promise<ContentResponseV2> {
    const response = await this.getContentV2Raw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * The URL pattern is basically \'from\' and \'to\' reference specs separated by \'/diff/\'  Examples:  - main/diff/myBranch - main@1234567890123456/diff/myBranch - main@1234567890123456/diff/myBranch@23445678 - main/diff/myBranch@23445678 - main/diff/myBranch@23445678 - my/branch@/diff/main - myBranch/diff/-
   * Get contents that differ in the trees specified by the two given references
   */
  async getDiffV2Raw(
    requestParameters: GetDiffV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<DiffResponseV2>> {
    if (
      requestParameters.fromRef === null ||
      requestParameters.fromRef === undefined
    ) {
      throw new runtime.RequiredError(
        "fromRef",
        "Required parameter requestParameters.fromRef was null or undefined when calling getDiffV2.",
      );
    }

    if (
      requestParameters.toRef === null ||
      requestParameters.toRef === undefined
    ) {
      throw new runtime.RequiredError(
        "toRef",
        "Required parameter requestParameters.toRef was null or undefined when calling getDiffV2.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.maxRecords !== undefined) {
      queryParameters["max-records"] = requestParameters.maxRecords;
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters["page-token"] = requestParameters.pageToken;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v2/trees/{from-ref}/diff/{to-ref}`
          .replace(
            `{${"from-ref"}}`,
            encodeURIComponent(String(requestParameters.fromRef)),
          )
          .replace(
            `{${"to-ref"}}`,
            encodeURIComponent(String(requestParameters.toRef)),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * The URL pattern is basically \'from\' and \'to\' reference specs separated by \'/diff/\'  Examples:  - main/diff/myBranch - main@1234567890123456/diff/myBranch - main@1234567890123456/diff/myBranch@23445678 - main/diff/myBranch@23445678 - main/diff/myBranch@23445678 - my/branch@/diff/main - myBranch/diff/-
   * Get contents that differ in the trees specified by the two given references
   */
  async getDiffV2(
    requestParameters: GetDiffV2Request,
    initOverrides?: RequestInit,
  ): Promise<DiffResponseV2> {
    const response = await this.getDiffV2Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Retrieves objects for a ref, potentially truncated by the backend.  Retrieves up to \'maxRecords\' entries for the given named reference (tag or branch) or the given hash. The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all available data in one page.  Different pages may have different numbers of log records in them even if they come from another call to this method with the same parameters. Also, pages are not guaranteed to be filled to contain exactly \'maxRecords\' even if the total amount of available data allows that. Pages may contain more of less entries at server\'s discretion.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.
   * Fetch all entries for a given reference
   */
  async getEntriesV2Raw(
    requestParameters: GetEntriesV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<EntriesResponseV2>> {
    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling getEntriesV2.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.content !== undefined) {
      queryParameters["content"] = requestParameters.content;
    }

    if (requestParameters.filter !== undefined) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.maxRecords !== undefined) {
      queryParameters["max-records"] = requestParameters.maxRecords;
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters["page-token"] = requestParameters.pageToken;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v2/trees/{ref}/entries`.replace(
          `{${"ref"}}`,
          encodeURIComponent(String(requestParameters.ref)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Retrieves objects for a ref, potentially truncated by the backend.  Retrieves up to \'maxRecords\' entries for the given named reference (tag or branch) or the given hash. The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all available data in one page.  Different pages may have different numbers of log records in them even if they come from another call to this method with the same parameters. Also, pages are not guaranteed to be filled to contain exactly \'maxRecords\' even if the total amount of available data allows that. Pages may contain more of less entries at server\'s discretion.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.
   * Fetch all entries for a given reference
   */
  async getEntriesV2(
    requestParameters: GetEntriesV2Request,
    initOverrides?: RequestInit,
  ): Promise<EntriesResponseV2> {
    const response = await this.getEntriesV2Raw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Similar to \'GET /trees/{ref}/content/{key}\', but takes multiple \'ContentKey\'s (in the JSON payload) and returns zero or more content objects.  Note that if some keys from the request do not have an associated content object at the point in history defined by the \'ref\' parameter, the response will be successful, but no data will be returned for the missing keys.
   * Get multiple content objects.
   */
  async getMultipleContentsV2Raw(
    requestParameters: GetMultipleContentsV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<GetMultipleContentsResponseV2>> {
    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling getMultipleContentsV2.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v2/trees/{ref}/contents`.replace(
          `{${"ref"}}`,
          encodeURIComponent(String(requestParameters.ref)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.getMultipleContentsRequest,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Similar to \'GET /trees/{ref}/content/{key}\', but takes multiple \'ContentKey\'s (in the JSON payload) and returns zero or more content objects.  Note that if some keys from the request do not have an associated content object at the point in history defined by the \'ref\' parameter, the response will be successful, but no data will be returned for the missing keys.
   * Get multiple content objects.
   */
  async getMultipleContentsV2(
    requestParameters: GetMultipleContentsV2Request,
    initOverrides?: RequestInit,
  ): Promise<GetMultipleContentsResponseV2> {
    const response = await this.getMultipleContentsV2Raw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Fetch details of a reference
   */
  async getReferenceByNameV2Raw(
    requestParameters: GetReferenceByNameV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<SingleReferenceResponseV2>> {
    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling getReferenceByNameV2.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.fetch !== undefined) {
      queryParameters["fetch"] = requestParameters.fetch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v2/trees/{ref}`.replace(
          `{${"ref"}}`,
          encodeURIComponent(String(requestParameters.ref)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Fetch details of a reference
   */
  async getReferenceByNameV2(
    requestParameters: GetReferenceByNameV2Request,
    initOverrides?: RequestInit,
  ): Promise<SingleReferenceResponseV2> {
    const response = await this.getReferenceByNameV2Raw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Similar to \'GET /trees/{ref}/content/{key}\', but takes multiple \'key\' query parameters and returns zero or more content values in the same JSON structure as the \'POST /trees/{ref}/content\' endpoint.  This is a convenience method for fetching a small number of content objects. It is mostly intended for human use. For automated use cases or when the number of keys is large the \'POST /trees/{ref}/content\' method is preferred.
   * Get multiple content objects.
   */
  async getSeveralContentsRaw(
    requestParameters: GetSeveralContentsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<GetMultipleContentsResponseV2>> {
    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling getSeveralContents.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.key) {
      queryParameters["key"] = requestParameters.key;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v2/trees/{ref}/contents`.replace(
          `{${"ref"}}`,
          encodeURIComponent(String(requestParameters.ref)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Similar to \'GET /trees/{ref}/content/{key}\', but takes multiple \'key\' query parameters and returns zero or more content values in the same JSON structure as the \'POST /trees/{ref}/content\' endpoint.  This is a convenience method for fetching a small number of content objects. It is mostly intended for human use. For automated use cases or when the number of keys is large the \'POST /trees/{ref}/content\' method is preferred.
   * Get multiple content objects.
   */
  async getSeveralContents(
    requestParameters: GetSeveralContentsRequest,
    initOverrides?: RequestInit,
  ): Promise<GetMultipleContentsResponseV2> {
    const response = await this.getSeveralContentsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Merge commits referenced by the \'mergeRefName\' and \'fromHash\' parameters of the payload object into the requested \'branch\'.  The state of contents specified by the \'branch\' reference will be used for detecting conflicts with the commits being transplanted.  The merge is committed if it is free from conflicts. The set of commits merged into the target branch will be all of those starting at \'fromHash\' on \'mergeRefName\' until we arrive at the common ancestor. Depending on the underlying implementation, the number of commits allowed as part of this operation may be limited.
   * Merge commits from another reference onto \'branch\'.
   */
  async mergeV2Raw(
    requestParameters: MergeV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<MergeResponseV2>> {
    if (
      requestParameters.branch === null ||
      requestParameters.branch === undefined
    ) {
      throw new runtime.RequiredError(
        "branch",
        "Required parameter requestParameters.branch was null or undefined when calling mergeV2.",
      );
    }

    if (
      requestParameters.merge === null ||
      requestParameters.merge === undefined
    ) {
      throw new runtime.RequiredError(
        "merge",
        "Required parameter requestParameters.merge was null or undefined when calling mergeV2.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v2/trees/{branch}/history/merge`.replace(
          `{${"branch"}}`,
          encodeURIComponent(String(requestParameters.branch)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.merge,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Merge commits referenced by the \'mergeRefName\' and \'fromHash\' parameters of the payload object into the requested \'branch\'.  The state of contents specified by the \'branch\' reference will be used for detecting conflicts with the commits being transplanted.  The merge is committed if it is free from conflicts. The set of commits merged into the target branch will be all of those starting at \'fromHash\' on \'mergeRefName\' until we arrive at the common ancestor. Depending on the underlying implementation, the number of commits allowed as part of this operation may be limited.
   * Merge commits from another reference onto \'branch\'.
   */
  async mergeV2(
    requestParameters: MergeV2Request,
    initOverrides?: RequestInit,
  ): Promise<MergeResponseV2> {
    const response = await this.mergeV2Raw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * This is done as an atomic operation such that only the last of the sequence is ever visible to concurrent readers/writers. The sequence to transplant must be contiguous and in order.  The state of contents specified by the \'branch\' reference will be used for detecting conflicts with the commits being transplanted.
   * Transplant commits specified by the \'Transplant\' payload object onto the given \'branch\'
   */
  async transplantV2Raw(
    requestParameters: TransplantV2Request,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<MergeResponseV2>> {
    if (
      requestParameters.branch === null ||
      requestParameters.branch === undefined
    ) {
      throw new runtime.RequiredError(
        "branch",
        "Required parameter requestParameters.branch was null or undefined when calling transplantV2.",
      );
    }

    if (
      requestParameters.transplant === null ||
      requestParameters.transplant === undefined
    ) {
      throw new runtime.RequiredError(
        "transplant",
        "Required parameter requestParameters.transplant was null or undefined when calling transplantV2.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v2/trees/{branch}/history/transplant`.replace(
          `{${"branch"}}`,
          encodeURIComponent(String(requestParameters.branch)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.transplant,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * This is done as an atomic operation such that only the last of the sequence is ever visible to concurrent readers/writers. The sequence to transplant must be contiguous and in order.  The state of contents specified by the \'branch\' reference will be used for detecting conflicts with the commits being transplanted.
   * Transplant commits specified by the \'Transplant\' payload object onto the given \'branch\'
   */
  async transplantV2(
    requestParameters: TransplantV2Request,
    initOverrides?: RequestInit,
  ): Promise<MergeResponseV2> {
    const response = await this.transplantV2Raw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}
