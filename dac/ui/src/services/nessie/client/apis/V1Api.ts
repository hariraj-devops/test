/* tslint:disable */

/**
 * Nessie API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: ${project.version}
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import {
  BranchV1,
  ContentV1,
  DiffResponseV1,
  EntriesResponseV1,
  FetchOption,
  GetMultipleContentsRequest,
  GetMultipleContentsResponseV1,
  GetNamespacesResponseV1,
  LogResponseV1,
  Merge1,
  MergeResponseV1,
  Namespace,
  NamespaceUpdate,
  NamespaceV1,
  NessieConfigurationV1,
  Operations,
  Reference,
  ReferenceType,
  ReferenceV1,
  ReferencesResponseV1,
  Transplant1,
} from "../models";

export interface AssignReferenceRequest {
  referenceName: string;
  referenceType: ReferenceType;
  expectedHash: string;
  reference?: Reference;
}

export interface CommitMultipleOperationsRequest {
  branchName: string;
  expectedHash?: string;
  operations?: Operations;
}

export interface CreateNamespaceRequest {
  name: Namespace;
  ref: string;
  hashOnRef?: string;
  namespace?: Namespace;
}

export interface CreateReferenceRequest {
  sourceRefName?: string;
  reference?: Reference;
}

export interface DeleteNamespaceRequest {
  name: Namespace;
  ref: string;
  hashOnRef?: string;
}

export interface DeleteReferenceRequest {
  referenceName: string;
  referenceType: ReferenceType;
  expectedHash: string;
}

export interface GetAllReferencesRequest {
  fetch?: FetchOption;
  filter?: string;
  maxRecords?: number;
  pageToken?: string;
}

export interface GetCommitLogRequest {
  ref: string;
  endHash?: string;
  fetch?: FetchOption;
  filter?: string;
  maxRecords?: number;
  pageToken?: string;
  startHash?: string;
}

export interface GetContentRequest {
  key: string;
  hashOnRef?: string;
  ref?: string;
}

export interface GetDiffRequest {
  fromRefWithHash: string;
  toRefWithHash: string;
}

export interface GetEntriesRequest {
  ref: string;
  filter?: string;
  hashOnRef?: string;
  maxRecords?: number;
  namespaceDepth?: number;
  pageToken?: string;
}

export interface GetMultipleContentsOperationRequest {
  hashOnRef?: string;
  ref?: string;
  getMultipleContentsRequest?: GetMultipleContentsRequest;
}

export interface GetNamespaceRequest {
  name: Namespace;
  ref: string;
  hashOnRef?: string;
}

export interface GetNamespacesRequest {
  ref: string;
  hashOnRef?: string;
  name?: Namespace;
}

export interface GetRefLogRequest {
  endHash?: string;
  filter?: string;
  maxRecords?: number;
  pageToken?: string;
  startHash?: string;
}

export interface GetReferenceByNameRequest {
  ref: string;
  fetch?: FetchOption;
}

export interface MergeRefIntoBranchRequest {
  branchName: string;
  expectedHash: string;
  merge1?: Merge1;
}

export interface TransplantCommitsIntoBranchRequest {
  branchName: string;
  expectedHash: string;
  message?: string;
  transplant1?: Transplant1;
}

export interface UpdatePropertiesRequest {
  name: Namespace;
  ref: string;
  hashOnRef?: string;
  namespaceUpdate?: NamespaceUpdate;
}

/**
 *
 */
export class V1Api extends runtime.BaseAPI {
  /**
   * This operation takes the name of the named reference to reassign and the hash and the name of a named-reference via which the caller has access to that hash.
   * Set a named reference to a specific hash via a named-reference.
   */
  async assignReferenceRaw(
    requestParameters: AssignReferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.referenceName === null ||
      requestParameters.referenceName === undefined
    ) {
      throw new runtime.RequiredError(
        "referenceName",
        "Required parameter requestParameters.referenceName was null or undefined when calling assignReference.",
      );
    }

    if (
      requestParameters.referenceType === null ||
      requestParameters.referenceType === undefined
    ) {
      throw new runtime.RequiredError(
        "referenceType",
        "Required parameter requestParameters.referenceType was null or undefined when calling assignReference.",
      );
    }

    if (
      requestParameters.expectedHash === null ||
      requestParameters.expectedHash === undefined
    ) {
      throw new runtime.RequiredError(
        "expectedHash",
        "Required parameter requestParameters.expectedHash was null or undefined when calling assignReference.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.expectedHash !== undefined) {
      queryParameters["expectedHash"] = requestParameters.expectedHash;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v1/trees/{referenceType}/{referenceName}`
          .replace(
            `{${"referenceName"}}`,
            encodeURIComponent(String(requestParameters.referenceName)),
          )
          .replace(
            `{${"referenceType"}}`,
            encodeURIComponent(String(requestParameters.referenceType)),
          ),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.reference,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * This operation takes the name of the named reference to reassign and the hash and the name of a named-reference via which the caller has access to that hash.
   * Set a named reference to a specific hash via a named-reference.
   */
  async assignReference(
    requestParameters: AssignReferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.assignReferenceRaw(requestParameters, initOverrides);
  }

  /**
   * Commit multiple operations against the given branch expecting that branch to have the given hash as its latest commit. The hash in the successful response contains the hash of the commit that contains the operations of the invocation.
   */
  async commitMultipleOperationsRaw(
    requestParameters: CommitMultipleOperationsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<BranchV1>> {
    if (
      requestParameters.branchName === null ||
      requestParameters.branchName === undefined
    ) {
      throw new runtime.RequiredError(
        "branchName",
        "Required parameter requestParameters.branchName was null or undefined when calling commitMultipleOperations.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.expectedHash !== undefined) {
      queryParameters["expectedHash"] = requestParameters.expectedHash;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v1/trees/branch/{branchName}/commit`.replace(
          `{${"branchName"}}`,
          encodeURIComponent(String(requestParameters.branchName)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.operations,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Commit multiple operations against the given branch expecting that branch to have the given hash as its latest commit. The hash in the successful response contains the hash of the commit that contains the operations of the invocation.
   */
  async commitMultipleOperations(
    requestParameters: CommitMultipleOperationsRequest,
    initOverrides?: RequestInit,
  ): Promise<BranchV1> {
    const response = await this.commitMultipleOperationsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Creates a Namespace
   */
  async createNamespaceRaw(
    requestParameters: CreateNamespaceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<NamespaceV1>> {
    if (
      requestParameters.name === null ||
      requestParameters.name === undefined
    ) {
      throw new runtime.RequiredError(
        "name",
        "Required parameter requestParameters.name was null or undefined when calling createNamespace.",
      );
    }

    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling createNamespace.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.hashOnRef !== undefined) {
      queryParameters["hashOnRef"] = requestParameters.hashOnRef;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v1/namespaces/namespace/{ref}/{name}`
          .replace(
            `{${"name"}}`,
            encodeURIComponent(String(requestParameters.name)),
          )
          .replace(
            `{${"ref"}}`,
            encodeURIComponent(String(requestParameters.ref)),
          ),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.namespace,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Creates a Namespace
   */
  async createNamespace(
    requestParameters: CreateNamespaceRequest,
    initOverrides?: RequestInit,
  ): Promise<NamespaceV1> {
    const response = await this.createNamespaceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * The type of \'refObj\', which can be either a \'Branch\' or \'Tag\', determines the type of the reference to be created.  \'Reference.name\' defines the the name of the reference to be created,\'Reference.hash\' is the hash of the created reference, the HEAD of the created reference. \'sourceRefName\' is the name of the reference which contains \'Reference.hash\', and must be present if \'Reference.hash\' is present.  Specifying no \'Reference.hash\' means that the new reference will be created \"at the beginning of time\".
   * Create a new reference
   */
  async createReferenceRaw(
    requestParameters: CreateReferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<ReferenceV1>> {
    const queryParameters: any = {};

    if (requestParameters.sourceRefName !== undefined) {
      queryParameters["sourceRefName"] = requestParameters.sourceRefName;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v1/trees/tree`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.reference,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * The type of \'refObj\', which can be either a \'Branch\' or \'Tag\', determines the type of the reference to be created.  \'Reference.name\' defines the the name of the reference to be created,\'Reference.hash\' is the hash of the created reference, the HEAD of the created reference. \'sourceRefName\' is the name of the reference which contains \'Reference.hash\', and must be present if \'Reference.hash\' is present.  Specifying no \'Reference.hash\' means that the new reference will be created \"at the beginning of time\".
   * Create a new reference
   */
  async createReference(
    requestParameters: CreateReferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<ReferenceV1> {
    const response = await this.createReferenceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Deletes a Namespace
   */
  async deleteNamespaceRaw(
    requestParameters: DeleteNamespaceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.name === null ||
      requestParameters.name === undefined
    ) {
      throw new runtime.RequiredError(
        "name",
        "Required parameter requestParameters.name was null or undefined when calling deleteNamespace.",
      );
    }

    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling deleteNamespace.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.hashOnRef !== undefined) {
      queryParameters["hashOnRef"] = requestParameters.hashOnRef;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/namespaces/namespace/{ref}/{name}`
          .replace(
            `{${"name"}}`,
            encodeURIComponent(String(requestParameters.name)),
          )
          .replace(
            `{${"ref"}}`,
            encodeURIComponent(String(requestParameters.ref)),
          ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Deletes a Namespace
   */
  async deleteNamespace(
    requestParameters: DeleteNamespaceRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.deleteNamespaceRaw(requestParameters, initOverrides);
  }

  /**
   * Delete a reference endpoint
   */
  async deleteReferenceRaw(
    requestParameters: DeleteReferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.referenceName === null ||
      requestParameters.referenceName === undefined
    ) {
      throw new runtime.RequiredError(
        "referenceName",
        "Required parameter requestParameters.referenceName was null or undefined when calling deleteReference.",
      );
    }

    if (
      requestParameters.referenceType === null ||
      requestParameters.referenceType === undefined
    ) {
      throw new runtime.RequiredError(
        "referenceType",
        "Required parameter requestParameters.referenceType was null or undefined when calling deleteReference.",
      );
    }

    if (
      requestParameters.expectedHash === null ||
      requestParameters.expectedHash === undefined
    ) {
      throw new runtime.RequiredError(
        "expectedHash",
        "Required parameter requestParameters.expectedHash was null or undefined when calling deleteReference.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.expectedHash !== undefined) {
      queryParameters["expectedHash"] = requestParameters.expectedHash;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/trees/{referenceType}/{referenceName}`
          .replace(
            `{${"referenceName"}}`,
            encodeURIComponent(String(requestParameters.referenceName)),
          )
          .replace(
            `{${"referenceType"}}`,
            encodeURIComponent(String(requestParameters.referenceType)),
          ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete a reference endpoint
   */
  async deleteReference(
    requestParameters: DeleteReferenceRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.deleteReferenceRaw(requestParameters, initOverrides);
  }

  /**
   * Get all references
   */
  async getAllReferencesRaw(
    requestParameters: GetAllReferencesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<ReferencesResponseV1>> {
    const queryParameters: any = {};

    if (requestParameters.fetch !== undefined) {
      queryParameters["fetch"] = requestParameters.fetch;
    }

    if (requestParameters.filter !== undefined) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.maxRecords !== undefined) {
      queryParameters["maxRecords"] = requestParameters.maxRecords;
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters["pageToken"] = requestParameters.pageToken;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/trees`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get all references
   */
  async getAllReferences(
    requestParameters: GetAllReferencesRequest,
    initOverrides?: RequestInit,
  ): Promise<ReferencesResponseV1> {
    const response = await this.getAllReferencesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Retrieve the commit log for a ref, potentially truncated by the backend.  Retrieves up to \'maxRecords\' commit-log-entries starting at the HEAD of the given named reference (tag or branch) or the given hash. The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all commit log entries.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.
   * Get commit log for a reference
   */
  async getCommitLogRaw(
    requestParameters: GetCommitLogRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<LogResponseV1>> {
    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling getCommitLog.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.endHash !== undefined) {
      queryParameters["endHash"] = requestParameters.endHash;
    }

    if (requestParameters.fetch !== undefined) {
      queryParameters["fetch"] = requestParameters.fetch;
    }

    if (requestParameters.filter !== undefined) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.maxRecords !== undefined) {
      queryParameters["maxRecords"] = requestParameters.maxRecords;
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters["pageToken"] = requestParameters.pageToken;
    }

    if (requestParameters.startHash !== undefined) {
      queryParameters["startHash"] = requestParameters.startHash;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/trees/tree/{ref}/log`.replace(
          `{${"ref"}}`,
          encodeURIComponent(String(requestParameters.ref)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Retrieve the commit log for a ref, potentially truncated by the backend.  Retrieves up to \'maxRecords\' commit-log-entries starting at the HEAD of the given named reference (tag or branch) or the given hash. The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all commit log entries.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.
   * Get commit log for a reference
   */
  async getCommitLog(
    requestParameters: GetCommitLogRequest,
    initOverrides?: RequestInit,
  ): Promise<LogResponseV1> {
    const response = await this.getCommitLogRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * List all configuration settings
   */
  async getConfigRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<NessieConfigurationV1>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/config`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * List all configuration settings
   */
  async getConfig(initOverrides?: RequestInit): Promise<NessieConfigurationV1> {
    const response = await this.getConfigRaw(initOverrides);
    return await response.value();
  }

  /**
   * This operation returns the content-value for a content-key in a named-reference (a branch or tag).  If the table-metadata is tracked globally (Iceberg), Nessie returns a \'Content\' object, that contains the most up-to-date part for the globally tracked part (Iceberg: table-metadata) plus the per-Nessie-reference/hash specific part (Iceberg: snapshot-id, schema-id, partition-spec-id, default-sort-order-id).
   * Get object content associated with a key.
   */
  async getContentRaw(
    requestParameters: GetContentRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<ContentV1>> {
    if (requestParameters.key === null || requestParameters.key === undefined) {
      throw new runtime.RequiredError(
        "key",
        "Required parameter requestParameters.key was null or undefined when calling getContent.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.hashOnRef !== undefined) {
      queryParameters["hashOnRef"] = requestParameters.hashOnRef;
    }

    if (requestParameters.ref !== undefined) {
      queryParameters["ref"] = requestParameters.ref;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/contents/{key}`.replace(
          `{${"key"}}`,
          encodeURIComponent(String(requestParameters.key)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * This operation returns the content-value for a content-key in a named-reference (a branch or tag).  If the table-metadata is tracked globally (Iceberg), Nessie returns a \'Content\' object, that contains the most up-to-date part for the globally tracked part (Iceberg: table-metadata) plus the per-Nessie-reference/hash specific part (Iceberg: snapshot-id, schema-id, partition-spec-id, default-sort-order-id).
   * Get object content associated with a key.
   */
  async getContent(
    requestParameters: GetContentRequest,
    initOverrides?: RequestInit,
  ): Promise<ContentV1> {
    const response = await this.getContentRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get default branch for commits and reads
   */
  async getDefaultBranchRaw(
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<BranchV1>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/trees/tree`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Get default branch for commits and reads
   */
  async getDefaultBranch(initOverrides?: RequestInit): Promise<BranchV1> {
    const response = await this.getDefaultBranchRaw(initOverrides);
    return await response.value();
  }

  /**
   * The URL pattern is basically \'from\' and \'to\' separated by \'...\' (three dots). \'from\' and \'to\' must start with a reference name, optionally followed by hash on that reference, the hash prefixed with the\'*\' character.  Examples:    diffs/main...myBranch   diffs/main...myBranch\\*1234567890123456   diffs/main\\*1234567890123456...myBranch   diffs/main\\*1234567890123456...myBranch\\*1234567890123456
   * Get a diff for two given references
   */
  async getDiffRaw(
    requestParameters: GetDiffRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<DiffResponseV1>> {
    if (
      requestParameters.fromRefWithHash === null ||
      requestParameters.fromRefWithHash === undefined
    ) {
      throw new runtime.RequiredError(
        "fromRefWithHash",
        "Required parameter requestParameters.fromRefWithHash was null or undefined when calling getDiff.",
      );
    }

    if (
      requestParameters.toRefWithHash === null ||
      requestParameters.toRefWithHash === undefined
    ) {
      throw new runtime.RequiredError(
        "toRefWithHash",
        "Required parameter requestParameters.toRefWithHash was null or undefined when calling getDiff.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/diffs/{fromRefWithHash}...{toRefWithHash}`
          .replace(
            `{${"fromRefWithHash"}}`,
            encodeURIComponent(String(requestParameters.fromRefWithHash)),
          )
          .replace(
            `{${"toRefWithHash"}}`,
            encodeURIComponent(String(requestParameters.toRefWithHash)),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * The URL pattern is basically \'from\' and \'to\' separated by \'...\' (three dots). \'from\' and \'to\' must start with a reference name, optionally followed by hash on that reference, the hash prefixed with the\'*\' character.  Examples:    diffs/main...myBranch   diffs/main...myBranch\\*1234567890123456   diffs/main\\*1234567890123456...myBranch   diffs/main\\*1234567890123456...myBranch\\*1234567890123456
   * Get a diff for two given references
   */
  async getDiff(
    requestParameters: GetDiffRequest,
    initOverrides?: RequestInit,
  ): Promise<DiffResponseV1> {
    const response = await this.getDiffRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Retrieves objects for a ref, potentially truncated by the backend.  Retrieves up to \'maxRecords\' entries for the given named reference (tag or branch) or the given hash. The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all commit log entries.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.  The \'namespaceDepth\' parameter returns only the ContentKey components up to the depth of \'namespaceDepth\'. For example they key \'a.b.c.d\' with a depth of 3 will return \'a.b.c\'. The operation is guaranteed to not return  duplicates and therefore will never page.
   * Fetch all entries for a given reference
   */
  async getEntriesRaw(
    requestParameters: GetEntriesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<EntriesResponseV1>> {
    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling getEntries.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.filter !== undefined) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.hashOnRef !== undefined) {
      queryParameters["hashOnRef"] = requestParameters.hashOnRef;
    }

    if (requestParameters.maxRecords !== undefined) {
      queryParameters["maxRecords"] = requestParameters.maxRecords;
    }

    if (requestParameters.namespaceDepth !== undefined) {
      queryParameters["namespaceDepth"] = requestParameters.namespaceDepth;
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters["pageToken"] = requestParameters.pageToken;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/trees/tree/{ref}/entries`.replace(
          `{${"ref"}}`,
          encodeURIComponent(String(requestParameters.ref)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Retrieves objects for a ref, potentially truncated by the backend.  Retrieves up to \'maxRecords\' entries for the given named reference (tag or branch) or the given hash. The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all commit log entries.  The \'filter\' parameter allows for advanced filtering capabilities using the Common Expression Language (CEL). An intro to CEL can be found at https://github.com/google/cel-spec/blob/master/doc/intro.md.  The \'namespaceDepth\' parameter returns only the ContentKey components up to the depth of \'namespaceDepth\'. For example they key \'a.b.c.d\' with a depth of 3 will return \'a.b.c\'. The operation is guaranteed to not return  duplicates and therefore will never page.
   * Fetch all entries for a given reference
   */
  async getEntries(
    requestParameters: GetEntriesRequest,
    initOverrides?: RequestInit,
  ): Promise<EntriesResponseV1> {
    const response = await this.getEntriesRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Similar to \'getContent\', but takes multiple \'ContentKey\'s and returns the content-values for the one or more content-keys in a named-reference (a branch or tag).  If the table-metadata is tracked globally (Iceberg), Nessie returns a \'Content\' object, that contains the most up-to-date part for the globally tracked part (Iceberg: table-metadata) plus the per-Nessie-reference/hash specific part (Iceberg: snapshot-ID,schema-ID, partition-spec-ID, default-sort-order-ID).
   * Get multiple objects\' content.
   */
  async getMultipleContentsRaw(
    requestParameters: GetMultipleContentsOperationRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<GetMultipleContentsResponseV1>> {
    const queryParameters: any = {};

    if (requestParameters.hashOnRef !== undefined) {
      queryParameters["hashOnRef"] = requestParameters.hashOnRef;
    }

    if (requestParameters.ref !== undefined) {
      queryParameters["ref"] = requestParameters.ref;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v1/contents`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.getMultipleContentsRequest,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Similar to \'getContent\', but takes multiple \'ContentKey\'s and returns the content-values for the one or more content-keys in a named-reference (a branch or tag).  If the table-metadata is tracked globally (Iceberg), Nessie returns a \'Content\' object, that contains the most up-to-date part for the globally tracked part (Iceberg: table-metadata) plus the per-Nessie-reference/hash specific part (Iceberg: snapshot-ID,schema-ID, partition-spec-ID, default-sort-order-ID).
   * Get multiple objects\' content.
   */
  async getMultipleContents(
    requestParameters: GetMultipleContentsOperationRequest,
    initOverrides?: RequestInit,
  ): Promise<GetMultipleContentsResponseV1> {
    const response = await this.getMultipleContentsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Retrieves a Namespace
   */
  async getNamespaceRaw(
    requestParameters: GetNamespaceRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<NamespaceV1>> {
    if (
      requestParameters.name === null ||
      requestParameters.name === undefined
    ) {
      throw new runtime.RequiredError(
        "name",
        "Required parameter requestParameters.name was null or undefined when calling getNamespace.",
      );
    }

    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling getNamespace.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.hashOnRef !== undefined) {
      queryParameters["hashOnRef"] = requestParameters.hashOnRef;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/namespaces/namespace/{ref}/{name}`
          .replace(
            `{${"name"}}`,
            encodeURIComponent(String(requestParameters.name)),
          )
          .replace(
            `{${"ref"}}`,
            encodeURIComponent(String(requestParameters.ref)),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Retrieves a Namespace
   */
  async getNamespace(
    requestParameters: GetNamespaceRequest,
    initOverrides?: RequestInit,
  ): Promise<NamespaceV1> {
    const response = await this.getNamespaceRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async getNamespacesRaw(
    requestParameters: GetNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<GetNamespacesResponseV1>> {
    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling getNamespaces.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.hashOnRef !== undefined) {
      queryParameters["hashOnRef"] = requestParameters.hashOnRef;
    }

    if (requestParameters.name !== undefined) {
      queryParameters["name"] = requestParameters.name;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/namespaces/{ref}`.replace(
          `{${"ref"}}`,
          encodeURIComponent(String(requestParameters.ref)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   */
  async getNamespaces(
    requestParameters: GetNamespacesRequest,
    initOverrides?: RequestInit,
  ): Promise<GetNamespacesResponseV1> {
    const response = await this.getNamespacesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * The Nessie reflog in this form is deprecated, likely for removal. Retrieve the reflog entries from a specified endHash or from the current HEAD if the endHash is null, potentially truncated by the backend.  Retrieves up to \'maxRecords\' refLog-entries starting at the endHash or HEAD.The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all reflog entries.
   * Get reflog entries (DEPRECATED)
   */
  async getRefLogRaw(
    requestParameters: GetRefLogRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<any>> {
    const queryParameters: any = {};

    if (requestParameters.endHash !== undefined) {
      queryParameters["endHash"] = requestParameters.endHash;
    }

    if (requestParameters.filter !== undefined) {
      queryParameters["filter"] = requestParameters.filter;
    }

    if (requestParameters.maxRecords !== undefined) {
      queryParameters["maxRecords"] = requestParameters.maxRecords;
    }

    if (requestParameters.pageToken !== undefined) {
      queryParameters["pageToken"] = requestParameters.pageToken;
    }

    if (requestParameters.startHash !== undefined) {
      queryParameters["startHash"] = requestParameters.startHash;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/reflogs`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.TextApiResponse(response) as any;
  }

  /**
   * The Nessie reflog in this form is deprecated, likely for removal. Retrieve the reflog entries from a specified endHash or from the current HEAD if the endHash is null, potentially truncated by the backend.  Retrieves up to \'maxRecords\' refLog-entries starting at the endHash or HEAD.The backend may respect the given \'max\' records hint, but return less or more entries. Backends may also cap the returned entries at a hard-coded limit, the default REST server implementation has such a hard-coded limit.  To implement paging, check \'hasMore\' in the response and, if \'true\', pass the value returned as \'token\' in the next invocation as the \'pageToken\' parameter.  The content and meaning of the returned \'token\' is \"private\" to the implementation,treat is as an opaque value.  It is wrong to assume that invoking this method with a very high \'maxRecords\' value will return all reflog entries.
   * Get reflog entries (DEPRECATED)
   */
  async getRefLog(
    requestParameters: GetRefLogRequest,
    initOverrides?: RequestInit,
  ): Promise<any> {
    const response = await this.getRefLogRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Fetch details of a reference
   */
  async getReferenceByNameRaw(
    requestParameters: GetReferenceByNameRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<ReferenceV1>> {
    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling getReferenceByName.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.fetch !== undefined) {
      queryParameters["fetch"] = requestParameters.fetch;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/trees/tree/{ref}`.replace(
          `{${"ref"}}`,
          encodeURIComponent(String(requestParameters.ref)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Fetch details of a reference
   */
  async getReferenceByName(
    requestParameters: GetReferenceByNameRequest,
    initOverrides?: RequestInit,
  ): Promise<ReferenceV1> {
    const response = await this.getReferenceByNameRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Merge items from an existing hash in \'mergeRef\' into the requested branch. The merge is always a rebase + fast-forward merge and is only completed if the rebase is conflict free. The set of commits added to the branch will be all of those until we arrive at a common ancestor. Depending on the underlying implementation, the number of commits allowed as part of this operation may be limited.
   * Merge commits from \'mergeRef\' onto \'branchName\'.
   */
  async mergeRefIntoBranchRaw(
    requestParameters: MergeRefIntoBranchRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<MergeResponseV1>> {
    if (
      requestParameters.branchName === null ||
      requestParameters.branchName === undefined
    ) {
      throw new runtime.RequiredError(
        "branchName",
        "Required parameter requestParameters.branchName was null or undefined when calling mergeRefIntoBranch.",
      );
    }

    if (
      requestParameters.expectedHash === null ||
      requestParameters.expectedHash === undefined
    ) {
      throw new runtime.RequiredError(
        "expectedHash",
        "Required parameter requestParameters.expectedHash was null or undefined when calling mergeRefIntoBranch.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.expectedHash !== undefined) {
      queryParameters["expectedHash"] = requestParameters.expectedHash;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v1/trees/branch/{branchName}/merge`.replace(
          `{${"branchName"}}`,
          encodeURIComponent(String(requestParameters.branchName)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.merge1,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * Merge items from an existing hash in \'mergeRef\' into the requested branch. The merge is always a rebase + fast-forward merge and is only completed if the rebase is conflict free. The set of commits added to the branch will be all of those until we arrive at a common ancestor. Depending on the underlying implementation, the number of commits allowed as part of this operation may be limited.
   * Merge commits from \'mergeRef\' onto \'branchName\'.
   */
  async mergeRefIntoBranch(
    requestParameters: MergeRefIntoBranchRequest,
    initOverrides?: RequestInit,
  ): Promise<MergeResponseV1> {
    const response = await this.mergeRefIntoBranchRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * This is done as an atomic operation such that only the last of the sequence is ever visible to concurrent readers/writers. The sequence to transplant must be contiguous and in order.
   * Transplant commits from \'transplant\' onto \'branchName\'
   */
  async transplantCommitsIntoBranchRaw(
    requestParameters: TransplantCommitsIntoBranchRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<MergeResponseV1>> {
    if (
      requestParameters.branchName === null ||
      requestParameters.branchName === undefined
    ) {
      throw new runtime.RequiredError(
        "branchName",
        "Required parameter requestParameters.branchName was null or undefined when calling transplantCommitsIntoBranch.",
      );
    }

    if (
      requestParameters.expectedHash === null ||
      requestParameters.expectedHash === undefined
    ) {
      throw new runtime.RequiredError(
        "expectedHash",
        "Required parameter requestParameters.expectedHash was null or undefined when calling transplantCommitsIntoBranch.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.expectedHash !== undefined) {
      queryParameters["expectedHash"] = requestParameters.expectedHash;
    }

    if (requestParameters.message !== undefined) {
      queryParameters["message"] = requestParameters.message;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v1/trees/branch/{branchName}/transplant`.replace(
          `{${"branchName"}}`,
          encodeURIComponent(String(requestParameters.branchName)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.transplant1,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response);
  }

  /**
   * This is done as an atomic operation such that only the last of the sequence is ever visible to concurrent readers/writers. The sequence to transplant must be contiguous and in order.
   * Transplant commits from \'transplant\' onto \'branchName\'
   */
  async transplantCommitsIntoBranch(
    requestParameters: TransplantCommitsIntoBranchRequest,
    initOverrides?: RequestInit,
  ): Promise<MergeResponseV1> {
    const response = await this.transplantCommitsIntoBranchRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async updatePropertiesRaw(
    requestParameters: UpdatePropertiesRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.name === null ||
      requestParameters.name === undefined
    ) {
      throw new runtime.RequiredError(
        "name",
        "Required parameter requestParameters.name was null or undefined when calling updateProperties.",
      );
    }

    if (requestParameters.ref === null || requestParameters.ref === undefined) {
      throw new runtime.RequiredError(
        "ref",
        "Required parameter requestParameters.ref was null or undefined when calling updateProperties.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.hashOnRef !== undefined) {
      queryParameters["hashOnRef"] = requestParameters.hashOnRef;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/api/v1/namespaces/namespace/{ref}/{name}`
          .replace(
            `{${"name"}}`,
            encodeURIComponent(String(requestParameters.name)),
          )
          .replace(
            `{${"ref"}}`,
            encodeURIComponent(String(requestParameters.ref)),
          ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.namespaceUpdate,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async updateProperties(
    requestParameters: UpdatePropertiesRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.updatePropertiesRaw(requestParameters, initOverrides);
  }
}
