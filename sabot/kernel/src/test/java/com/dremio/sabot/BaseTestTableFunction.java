/*
 * Copyright (C) 2017-2019 Dremio Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.dremio.sabot;

import com.dremio.common.AutoCloseables;
import com.dremio.exec.physical.config.TableFunctionPOP;
import com.dremio.exec.record.RecordBatchData;
import com.dremio.exec.record.VectorAccessible;
import com.dremio.exec.record.VectorWrapper;
import com.dremio.sabot.op.spi.SingleInputOperator;
import com.dremio.sabot.op.tablefunction.TableFunctionOperator;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.arrow.memory.ArrowBuf;
import org.apache.arrow.vector.ValueVector;
import org.junit.Assert;

public class BaseTestTableFunction extends BaseTestOperator {

  protected void validateOutputBufferNotReused(
      TableFunctionPOP pop, Generator.Creator input, int batchSize) throws Exception {
    final List<RecordBatchData> data = new ArrayList<>();

    boolean singleBatch = true;
    Map<ValueVector, ArrowBuf> vectorBuffers = new HashMap<>();
    try (TableFunctionOperator op = newOperator(TableFunctionOperator.class, pop, batchSize);
        Generator generator = input.toGenerator(getTestAllocator())) {

      final VectorAccessible output = op.setup(generator.getOutput());
      int count;
      while (op.getState() != SingleInputOperator.State.DONE
          && (count = generator.next(batchSize)) != 0) {
        assertState(op, SingleInputOperator.State.CAN_CONSUME);
        op.consumeData(count);
        while (op.getState() == SingleInputOperator.State.CAN_PRODUCE) {
          if (op.outputData() > 0) {
            for (VectorWrapper<?> wrapper : output) {
              ValueVector vv = wrapper.getValueVector();
              if (!vectorBuffers.containsKey(vv)) {
                vectorBuffers.put(vv, vv.getBuffers(false)[0]);
              } else {
                singleBatch = false;
                Assert.assertNotEquals(
                    "Output buffer reused", vectorBuffers.get(vv), vv.getBuffers(false)[0]);
              }
            }
            data.add(new RecordBatchData(output, getTestAllocator()));
          }
        }
      }

      if (op.getState() == SingleInputOperator.State.CAN_CONSUME) {
        op.noMoreToConsume();
      }

      while (op.getState() == SingleInputOperator.State.CAN_PRODUCE) {
        if (op.outputData() > 0) {
          for (VectorWrapper<?> wrapper : output) {
            ValueVector vv = wrapper.getValueVector();
            if (!vectorBuffers.containsKey(vv)) {
              vectorBuffers.put(vv, vv.getBuffers(false)[0]);
            } else {
              singleBatch = false;
              Assert.assertNotEquals(
                  "Output buffer reused", vectorBuffers.get(vv), vv.getBuffers(false)[0]);
            }
          }
          data.add(new RecordBatchData(output, getTestAllocator()));
        }
      }

      if (op.getState() == SingleInputOperator.State.CAN_CONSUME) {
        op.noMoreToConsume();
      }

      Assert.assertFalse(
          "There must be multiple output batches generated by the test to verify if buffers are reused.",
          singleBatch);
      assertState(op, SingleInputOperator.State.DONE);
    } finally {
      AutoCloseables.close(data);
    }
  }

  protected List<RecordBatchData> getTableFunctionOutput(
      TableFunctionPOP pop,
      Generator generator,
      int batchSize,
      OperatorTestContext operatorTestContext)
      throws Exception {
    return getTableFunctionOutput(pop, generator, batchSize, batchSize, operatorTestContext);
  }

  protected List<RecordBatchData> getTableFunctionOutput(
      TableFunctionPOP pop,
      Generator generator,
      int inputBatchSize,
      int outputBatchSize,
      OperatorTestContext operatorTestContext)
      throws Exception {
    final List<RecordBatchData> data = new ArrayList<>();

    try (TableFunctionOperator op =
        newOperatorWithStats(
                TableFunctionOperator.class, pop, outputBatchSize, null, null, operatorTestContext)
            .first) {

      final VectorAccessible output = op.setup(generator.getOutput());
      int count;
      while (op.getState() != SingleInputOperator.State.DONE
          && (count = generator.next(inputBatchSize)) != 0) {
        assertState(op, SingleInputOperator.State.CAN_CONSUME);
        op.consumeData(count);
        while (op.getState() == SingleInputOperator.State.CAN_PRODUCE) {
          if (op.outputData() > 0) {
            data.add(new RecordBatchData(output, getTestAllocator()));
          }
        }
      }

      if (op.getState() == SingleInputOperator.State.CAN_CONSUME) {
        op.noMoreToConsume();
      }

      while (op.getState() == SingleInputOperator.State.CAN_PRODUCE) {
        if (op.outputData() > 0) {
          data.add(new RecordBatchData(output, getTestAllocator()));
        }
      }

      if (op.getState() == SingleInputOperator.State.CAN_CONSUME) {
        op.noMoreToConsume();
      }
      assertState(op, SingleInputOperator.State.DONE);
    }

    return data;
  }
}
